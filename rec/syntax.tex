\marginpar{Основно следваме \cite[Глава 9]{winskel}}
\section{Синтаксис}
Ще разглеждаме един много прост език за функционално програмиране.
\begin{itemize}
\item
  \index{константа}
  \marginpar{За разлика от \cite{ditchev-soskov}, няма да въвеждаме термове от тип $\BB$}
  \marginpar{Константите не са числа! Константите са синтактични обекти, докато числата са семантични обекти}
  константи $\vv{n}\in\NN_\bot$, за всяко $n \in \Nat_\bot$;
  \Stefan{Да ги нарека обектови константи. По тази логика, операциите стават функционални константи}
\item
  \index{променлива!обектова}
  \index{променлива!нулев тип}
  \marginpar{Удобно е в нашия език още на синтактично ниво да правим разлика между двата типа променливи, които имаме в езика}
  изброимо много променливи от тип 0 (обектови променливи) $\vv{x}, \vv{y}, \vv{z}, \dots$, евентуално с индекси;
\item
  \index{променлива!функционална}
  изброимо много променливи от тип 1 (или функционални променливи) $\vv{f},\vv{g},\vv{h},\dots$, евентуално с индекси. 
  Формално погледнато, трябва на всяка функционална променлива $\vv{f}$
  да съпоставим число - брой аргументи, които приема. Нека да означим с $\#\vv{f}$ броя аргументи на $f$.
  Обикновено броят аргументи на $\vv{f}$ ще е ясен от контекста.
\item
  Термовете $\tau_0,\tau_1,\dots$ в {\bf REC} имат следния синтаксис:
  \marginpar{Тук $m_i = \#\vv{f}_i$}
  \[\tau ::= \vv{n} \mid \vv{x} \mid \tau_1 + \tau_2 \mid \tau_1\ \vv{==}\ \tau_2 \mid \ifelse{\tau_1}{\tau_2}{\tau_3} \mid \vv{f}_i(\tau_1,\dots,\tau_{m_i}).\]
\item
  Ще записваме $\tau[\vv{x}_1,\dots,\vv{x}_n,\vv{f}_1,\dots,\vv{f}_k]$, когато искаме да означим, че променливите
  на терма $\tau$ са {\em измежду} посочените.
\item
  С $\tau[\vv{x}/\mu]$ ще означаваме терма получен от $\tau$, в който всяко срещане на обектовата променлива $\vv{x}$
  е заменена с терма $\mu$.
\end{itemize}

\marginpar{\cite[стр. 141]{winskel}}

\index{рекурсивна програма}
Една {\bf рекурсивна програма} $\vv{P}$ на езика {\bf REC} има следния общ вид:
\marginpar{Една програма е просто текст със специален формат. Важният въпрос е каква функция (семантика) отговаря на този текст (синтаксис)}
\marginpar{Може да си мислите, че $\vv{f}_1$ е $\vv{main}$ функцията на нашата програма}
\begin{align*}
  \vv{P} = 
  \begin{cases}
    % & \vv{f}_0(\vv{x}_1,\dots,\vv{x}_{m_0}) = \tau_0[\vv{x}_1,\dots,\vv{x}_{m_0},\vv{f}_0,\vv{f}_1,\dots,\vv{f}_k]\ \texttt{where}\\
    & \vv{f}_1(\vv{x}_1,\dots,\vv{x}_{m_1}) = \tau_1[\vv{x}_1,\dots,\vv{x}_{m_1},\vv{f}_1,\dots,\vv{f}_k]\\
    & \vdots\\
    & \vv{f}_k(\vv{x}_1,\dots,\vv{x}_{m_k}) = \tau_k[\vv{x}_1,\dots,\vv{x}_{m_k},\vv{f}_1,\dots,\vv{f}_k]
  \end{cases}
\end{align*}

В такъв случай казваме, че термът $\tau_i$ задава {\em дефиницията} на фунционалната променлива $\vv{f}_i$.

\begin{example}
  \label{ex:minus}
  Да разгледаме програмата $\vv{P}$ на езика хаскел:
  \begin{haskellcode}
h(x) = f(x, 1)
f(x,y) = if x == y then 0 
           else f(x, y+1) + 1
  \end{haskellcode}
  Да положим
  \begin{align*}
    & \tau_1[\vv{x},\vv{h},\vv{f}] \dfff \vv{f}(\vv{x},\vv{1})\\
    & \tau_2[\vv{x},\vv{y},\vv{h},\vv{f}] \dfff \ifelse{\vv{x == y}}{\vv{0}}{\vv{f(x,y+1) + 1}}.
  \end{align*}
  Тогава програмата $\vv{P}$ приема следния вид:
  \begin{align*}
    & \vv{h}(\vv{x}) = \tau_1[\vv{x},\vv{h},\vv{f}]\\
    & \vv{f}(\vv{x},\vv{y}) = \tau_2[\vv{x},\vv{y},\vv{h},\vv{f}].
  \end{align*}
\end{example}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../sep"
%%% End:
